name: Cross-Workflow Coordination & Orchestration

on:
  workflow_run:
    workflows: [
      "Enhanced Matrix CI/CD Pipeline",
      "Enhanced Emergency Fallback & Self-Healing", 
      "Staging Environment & Deployment Pipeline",
      "CI/CD Pipeline",
      "Core Tests",
      "Dependencies",
      "Documentation"
    ]
    types: [completed, requested]
  schedule:
    # Orchestration health check every 4 hours
    - cron: '0 */4 * * *'
  repository_dispatch:
    types: [coordinate_workflows, health_check, emergency_coordination]

jobs:
  # Workflow state analysis
  workflow-state-analysis:
    runs-on: ubuntu-latest
    name: Workflow State Analysis
    outputs:
      workflow-health: ${{ steps.health.outputs.status }}
      coordination-needed: ${{ steps.coordination.outputs.needed }}
      priority-actions: ${{ steps.priority.outputs.actions }}
      
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install coordination tools
      run: |
        pip install requests pyyaml python-dateutil || echo "Some tools failed to install"
    
    - name: Analyze workflow ecosystem health
      id: health
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "üîç Analyzing workflow ecosystem health..."
        
        python3 << 'EOF'
        import requests
        import json
        import os
        from datetime import datetime, timedelta
        
        token = os.environ['GITHUB_TOKEN']
        repo = "${{ github.repository }}"
        headers = {'Authorization': f'token {token}', 'Accept': 'application/vnd.github.v3+json'}
        
        # Get recent workflow runs
        url = f"https://api.github.com/repos/{repo}/actions/runs?per_page=50"
        response = requests.get(url, headers=headers)
        runs = response.json().get('workflow_runs', [])
        
        # Analyze workflow health metrics
        workflow_stats = {}
        recent_failures = []
        
        for run in runs:
            workflow_name = run['name']
            conclusion = run['conclusion']
            created_at = datetime.fromisoformat(run['created_at'].replace('Z', '+00:00'))
            
            if workflow_name not in workflow_stats:
                workflow_stats[workflow_name] = {
                    'total': 0, 'success': 0, 'failure': 0, 'cancelled': 0,
                    'last_success': None, 'last_failure': None
                }
            
            workflow_stats[workflow_name]['total'] += 1
            
            if conclusion == 'success':
                workflow_stats[workflow_name]['success'] += 1
                if not workflow_stats[workflow_name]['last_success']:
                    workflow_stats[workflow_name]['last_success'] = created_at
            elif conclusion == 'failure':
                workflow_stats[workflow_name]['failure'] += 1
                if not workflow_stats[workflow_name]['last_failure']:
                    workflow_stats[workflow_name]['last_failure'] = created_at
                recent_failures.append({
                    'workflow': workflow_name,
                    'time': created_at,
                    'url': run['html_url']
                })
            elif conclusion == 'cancelled':
                workflow_stats[workflow_name]['cancelled'] += 1
        
        # Calculate overall health score
        total_runs = sum(stats['total'] for stats in workflow_stats.values())
        total_failures = sum(stats['failure'] for stats in workflow_stats.values())
        
        if total_runs > 0:
            failure_rate = total_failures / total_runs
            health_score = max(0, 100 - (failure_rate * 100))
        else:
            health_score = 100
        
        # Determine health status
        if health_score >= 90:
            health_status = "excellent"
        elif health_score >= 75:
            health_status = "good"
        elif health_score >= 60:
            health_status = "fair" 
        else:
            health_status = "poor"
        
        print(f"Workflow ecosystem health: {health_status} ({health_score:.1f}%)")
        print(f"Total runs analyzed: {total_runs}")
        print(f"Recent failures: {len([f for f in recent_failures if (datetime.now(f['time'].tzinfo) - f['time']).days < 1])}")
        
        # Save analysis results
        with open('workflow_health.json', 'w') as f:
            json.dump({
                'health_status': health_status,
                'health_score': health_score,
                'workflow_stats': workflow_stats,
                'recent_failures': recent_failures[:10]  # Last 10 failures
            }, f, indent=2, default=str)
        
        print(f"status={health_status}" >> os.environ['GITHUB_OUTPUT'])
        EOF
    
    - name: Determine coordination needs
      id: coordination
      run: |
        echo "ü§ù Analyzing coordination requirements..."
        
        python3 << 'EOF'
        import json
        import os
        from datetime import datetime, timedelta
        
        with open('workflow_health.json', 'r') as f:
            health_data = json.load(f)
        
        coordination_needed = False
        reasons = []
        
        # Check if coordination is needed based on failure patterns
        if health_data['health_status'] in ['poor', 'fair']:
            coordination_needed = True
            reasons.append("Low ecosystem health score")
        
        # Check for cascading failures
        recent_failures = health_data['recent_failures']
        if len(recent_failures) >= 3:
            coordination_needed = True
            reasons.append("Multiple recent failures detected")
        
        # Check for workflow blocking patterns
        workflow_stats = health_data['workflow_stats']
        critical_workflows = [
            'Enhanced Matrix CI/CD Pipeline',
            'CI/CD Pipeline', 
            'Core Tests'
        ]
        
        for workflow in critical_workflows:
            if workflow in workflow_stats:
                stats = workflow_stats[workflow]
                if stats['total'] > 0 and stats['failure'] / stats['total'] > 0.3:
                    coordination_needed = True
                    reasons.append(f"High failure rate in {workflow}")
        
        print(f"Coordination needed: {coordination_needed}")
        if reasons:
            print("Reasons:", ', '.join(reasons))
        
        print(f"needed={str(coordination_needed).lower()}" >> os.environ['GITHUB_OUTPUT'])
        EOF
    
    - name: Identify priority actions
      id: priority
      run: |
        echo "üéØ Identifying priority actions..."
        
        python3 << 'EOF'
        import json
        import os
        
        with open('workflow_health.json', 'r') as f:
            health_data = json.load(f)
        
        priority_actions = []
        
        # Priority 1: Critical workflow failures
        workflow_stats = health_data['workflow_stats']
        for workflow, stats in workflow_stats.items():
            if 'Enhanced' in workflow or 'CI/CD' in workflow:
                if stats.get('failure', 0) > 0 and stats.get('total', 0) > 0:
                    failure_rate = stats['failure'] / stats['total']
                    if failure_rate > 0.5:
                        priority_actions.append(f"CRITICAL: Fix {workflow} (failure rate: {failure_rate:.1%})")
        
        # Priority 2: Missing workflow coordination
        recent_failures = health_data['recent_failures']
        if len(recent_failures) >= 2:
            priority_actions.append("HIGH: Implement failure coordination")
        
        # Priority 3: Health monitoring
        if health_data['health_status'] in ['poor', 'fair']:
            priority_actions.append("MEDIUM: Enhance health monitoring")
        
        print("Priority actions identified:")
        for action in priority_actions[:5]:  # Top 5 priorities
            print(f"- {action}")
        
        actions_str = ';'.join(priority_actions[:3])  # Top 3 for output
        print(f"actions={actions_str}" >> os.environ['GITHUB_OUTPUT'])
        EOF

  # Workflow coordination execution
  coordinate-workflows:
    runs-on: ubuntu-latest
    needs: workflow-state-analysis
    if: needs.workflow-state-analysis.outputs.coordination-needed == 'true'
    name: Execute Workflow Coordination
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Coordinate failing workflows
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "ü§ù Executing workflow coordination..."
        
        # Get current repository dispatch events
        echo "üì° Triggering coordinated recovery actions..."
        
        # Trigger emergency fallback for critical failures
        curl -X POST \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/dispatches" \
          -d '{
            "event_type": "emergency_fallback",
            "client_payload": {
              "trigger": "coordination_system",
              "priority": "high",
              "ref": "${{ github.ref }}"
            }
          }'
        
        echo "üîÑ Coordination actions dispatched"
    
    - name: Implement cross-workflow recovery
      run: |
        echo "üõ†Ô∏è  Implementing cross-workflow recovery strategies..."
        
        # Strategy 1: Reset failed workflow states
        echo "1. Resetting failed workflow states..."
        
        # Strategy 2: Clear problematic caches
        echo "2. Clearing cross-workflow caches..."
        rm -rf ~/.cache/pip || echo "Cache clear completed"
        
        # Strategy 3: Validate workflow dependencies
        echo "3. Validating workflow dependencies..."
        python -c "
        import yaml
        import os
        
        workflows_dir = '.github/workflows'
        if os.path.exists(workflows_dir):
            for file in os.listdir(workflows_dir):
                if file.endswith('.yml') or file.endswith('.yaml'):
                    try:
                        with open(f'{workflows_dir}/{file}', 'r') as f:
                            yaml.safe_load(f)
                        print(f'‚úÖ {file} syntax valid')
                    except Exception as e:
                        print(f'‚ùå {file} syntax error: {e}')
        "
        
        echo "‚úÖ Cross-workflow recovery completed"

  # Ecosystem health optimization
  optimize-ecosystem-health:
    runs-on: ubuntu-latest
    needs: [workflow-state-analysis, coordinate-workflows]
    if: always()
    name: Optimize Ecosystem Health
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Implement health optimizations
      run: |
        echo "‚ö° Implementing ecosystem health optimizations..."
        
        # Optimization 1: Workflow scheduling coordination
        echo "1. Optimizing workflow scheduling..."
        
        # Create coordination schedule to prevent conflicts
        cat > .github/workflows/coordination_schedule.md << 'EOF'
        # Workflow Coordination Schedule
        
        ## Peak Hours (avoid heavy workflows)
        - 09:00-17:00 UTC (business hours)
        
        ## Optimal Windows
        - 02:00-05:00 UTC: Heavy matrix testing
        - 06:00-08:00 UTC: Documentation builds  
        - 18:00-20:00 UTC: Dependency updates
        - 22:00-01:00 UTC: Security scans
        
        ## Emergency Windows
        - Always available: Emergency fallback
        - Always available: Quick health checks
        EOF
        
        # Optimization 2: Resource usage balancing
        echo "2. Balancing resource usage across workflows..."
        
        # Optimization 3: Failure pattern analysis
        echo "3. Analyzing failure patterns for prevention..."
        
        echo "‚úÖ Health optimizations implemented"
    
    - name: Update coordination metrics
      run: |
        echo "üìä Updating coordination metrics..."
        
        # Create metrics dashboard data
        cat > coordination_metrics.json << EOF
        {
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "ecosystem_health": "${{ needs.workflow-state-analysis.outputs.workflow-health }}",
          "coordination_executed": "${{ needs.workflow-state-analysis.outputs.coordination-needed }}",
          "priority_actions": "${{ needs.workflow-state-analysis.outputs.priority-actions }}",
          "optimization_status": "completed"
        }
        EOF
        
        echo "üìà Metrics updated successfully"

  # Proactive monitoring setup
  setup-proactive-monitoring:
    runs-on: ubuntu-latest
    needs: workflow-state-analysis
    name: Setup Proactive Monitoring
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure intelligent monitoring
      run: |
        echo "üëÅÔ∏è  Setting up proactive monitoring..."
        
        # Create monitoring configuration
        mkdir -p .github/monitoring
        
        cat > .github/monitoring/workflow_monitor_config.yaml << 'EOF'
        monitoring:
          enabled: true
          check_interval: "*/15 * * * *"  # Every 15 minutes
          
        thresholds:
          failure_rate: 0.20  # Alert if >20% failure rate
          response_time: 900  # Alert if >15 minutes
          queue_time: 300     # Alert if >5 minutes queue time
          
        notifications:
          critical_failures: true
          ecosystem_health: true
          coordination_events: true
          
        recovery:
          auto_retry: true
          max_retries: 3
          backoff_strategy: "exponential"
          
        coordination:
          cross_workflow: true
          failure_analysis: true
          predictive_scaling: true
        EOF
        
        echo "üéØ Proactive monitoring configured"
    
    - name: Initialize monitoring dashboards
      run: |
        echo "üìä Initializing monitoring dashboards..."
        
        # Create dashboard configuration
        cat > .github/monitoring/dashboard_config.json << 'EOF'
        {
          "dashboards": {
            "workflow_health": {
              "metrics": [
                "success_rate",
                "failure_rate", 
                "execution_time",
                "queue_time"
              ],
              "timeframe": "24h"
            },
            "coordination": {
              "metrics": [
                "coordination_events",
                "auto_recoveries",
                "manual_interventions"
              ],
              "timeframe": "7d"
            },
            "ecosystem": {
              "metrics": [
                "overall_health_score",
                "workflow_dependencies",
                "resource_utilization"
              ],
              "timeframe": "30d"
            }
          }
        }
        EOF
        
        echo "üéõÔ∏è  Monitoring dashboards initialized"

  # Coordination status summary
  coordination-status-summary:
    runs-on: ubuntu-latest
    needs: [workflow-state-analysis, coordinate-workflows, optimize-ecosystem-health, setup-proactive-monitoring]
    if: always()
    name: Coordination Status Summary
    
    steps:
    - name: Generate coordination summary
      run: |
        echo "## ü§ù Cross-Workflow Coordination Report" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
        echo "**Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Ecosystem Health" >> $GITHUB_STEP_SUMMARY
        echo "- **Health Status**: ${{ needs.workflow-state-analysis.outputs.workflow-health }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Coordination Needed**: ${{ needs.workflow-state-analysis.outputs.coordination-needed }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Priority Actions**: ${{ needs.workflow-state-analysis.outputs.priority-actions }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Coordination Results" >> $GITHUB_STEP_SUMMARY
        echo "- **State Analysis**: ${{ needs.workflow-state-analysis.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Workflow Coordination**: ${{ needs.coordinate-workflows.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Health Optimization**: ${{ needs.optimize-ecosystem-health.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Proactive Monitoring**: ${{ needs.setup-proactive-monitoring.result }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "- Proactive monitoring active ‚úÖ" >> $GITHUB_STEP_SUMMARY
        echo "- Cross-workflow coordination enabled ‚úÖ" >> $GITHUB_STEP_SUMMARY
        echo "- Ecosystem health optimization running ‚úÖ" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "*Cross-Workflow Coordination v2.1 - Intelligent Orchestration*" >> $GITHUB_STEP_SUMMARY
